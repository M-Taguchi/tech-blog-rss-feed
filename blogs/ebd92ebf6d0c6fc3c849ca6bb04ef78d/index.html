<!doctype html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta name="author" content="yamadashy"><meta name="robots" content="index, follow"><meta property="og:url" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta property="og:title" content="sitateru tech blogのフィード｜企業テックブログRSS"><meta property="og:image" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><meta property="og:description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta property="og:type" content="website"><meta property="og:site_name" content="企業テックブログRSS"><meta name="twitter:card" content="summary"><meta property="twitter:domain" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta property="twitter:url" 
content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta name="twitter:title" content="sitateru tech blogのフィード｜企業テックブログRSS"><meta name="twitter:description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta name="twitter:image" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><meta name="google-site-verification" content="GPLvXv8kYtLMW912ZS54DKFEZL6ruOrjOFLdHVTo37o"><link rel="shortcut icon" href="../../images/favicon.ico"><link rel="apple-touch-icon" href="../../images/apple-icon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="../../feeds/atom.xml"><link rel="alternate" type="application/rss+xml" title="RSS2.0" href="../../feeds/rss.xml"><link rel="alternate" type="application/json" href="../../feeds/feed.json"><style>
*,::after,::before{box-sizing:border-box}*{margin:0}body,html{height:100%}body{line-height:1.5;-webkit-font-smoothing:antialiased}canvas,img,picture,svg,video{display:block;max-width:100%}button,input,select,textarea{font:inherit}h1,h2,h3,h4,h5,h6,p{overflow-wrap:break-word}#__next,#root{isolation:isolate}:root{--ui-color-brand:#353535;--ui-color-n-000:#fff;--ui-color-n-100:#ebebeb;--ui-color-n-300:#aeaeae;--ui-color-n-500:#353535;--ui-color-n-700:#282828;--ui-color-n-900:#1a1a1a;--ui-color-background-primary:var(--ui-color-n-000);--ui-color-form-input:var(--ui-color-n-100);--ui-color-typography-heading:var(--ui-color-n-500);--ui-color-typography-body:var(--ui-color-n-900);--ui-color-typography-note:var(--ui-color-n-300);--ui-color-typography-button:var(--ui-color-n-000);--ui-typography-typeface:"Inter",sans-serif;--ui-typography-h1:1.9375rem;--ui-typography-h2:1.5625rem;--ui-typography-h3:1.25rem;--ui-typography-p:1rem;--ui-typography-s:.8125rem;--ui-typography-h1-leading:1.2;--ui-typography-h2-leading:1.2;--ui-typography-h3-leading:1.25;--ui-typography-p-leading:1.5;--ui-typography-margin-heading:.75rem;--ui-typography-margin-body:1.125rem;--ui-layout-container:1.25rem;--ui-layout-grid:3.625rem;--ui-layout-gutter:1rem;--ui-gap-cta:.75rem;--ui-gap-content:2rem;--ui-radius-button:5rem;--ui-radius-input:5rem}html{box-sizing:border-box}*,:after,:before{box-sizing:inherit}body{background-color:var(--ui-color-background-primary);color:var(--ui-color-typography-body);font-family:var(--ui-typography-typeface);font-feature-settings:"liga","kern";font-size:var(--ui-typography-p);font-weight:400;line-height:var(--ui-typography-p-leading);margin:0 auto;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased}a{color:var(--ui-color-brand);text-decoration:none}h1,h2,h3,p{margin-top:0}h1,h2,h3{color:var(--ui-color-typography-heading);margin-bottom:var(--ui-typography-margin-heading)}h1{font-size:var(--ui-typography-h1);line-height:var(--ui-typography-h1-leading)}h2{font-size:var(--ui-typography-h2);line-height:var(--ui-typography-h2-leading)}h3{font-size:var(--ui-typography-h3);line-height:var(--ui-typography-h3-leading)}p{margin-bottom:var(--ui-typography-margin-body)}p:last-child{margin-bottom:0}strong{font-weight:700}small{font-size:var(--ui-typography-s)}.ui-text-note{color:var(--ui-color-typography-note);line-height:1}img,svg{display:block;height:auto;margin:0 auto;max-width:100%}.ui-layout-container{padding-left:var(--ui-layout-container);padding-right:var(--ui-layout-container)}.ui-layout-flex,.ui-layout-grid{align-items:center;justify-content:center}.ui-layout-flex{display:flex}.ui-layout-grid{display:grid}.ui-component-cta{flex-direction:column;row-gap:var(--ui-gap-cta)}button,input{color:inherit;font-family:inherit;font-size:var(--ui-typography-p);line-height:1;margin:0;outline:0;text-rendering:inherit;text-transform:none}form{width:100%}.ui-component-form{background-color:var(--ui-color-form-input);border-radius:var(--ui-radius-input);grid-template-columns:minmax(0,1fr) auto;padding:.25rem}::placeholder{color:var(--ui-color-typography-note)}.ui-component-input{background-color:var(--ui-color-form-input);border:.0625rem solid var(--ui-color-form-input);border-radius:var(--ui-radius-input)}.ui-component-input-medium{height:2.5rem;padding:.625rem 1rem .75rem}button{background:0 0;border:0;cursor:pointer;display:block;padding:0}.ui-component-button{border:.0625rem solid var(--ui-color-brand);border-radius:var(--ui-radius-button);display:block;font-weight:700;line-height:1;text-align:center}.ui-component-button-primary{background-color:var(--ui-color-brand);color:var(--ui-color-typography-button)}.ui-component-button-medium{padding:.625rem .875rem .75rem;width:fit-content}.ui-section-header{padding-bottom:1.25rem;padding-top:1.25rem}.ui-section-header__layout{justify-content:space-between}.ui-section-content{padding-bottom:2em;padding-top:5rem;text-align:center}.ui-section-content--image{margin-bottom:var(--ui-gap-content);margin-top:var(--ui-gap-content)}.ui-section-content--feature{row-gap:var(--ui-gap-content)}.ui-section-content--icon{margin-bottom:1rem}.ui-section-close{padding-bottom:5rem;padding-top:5rem;text-align:center}.ui-section-footer{padding-bottom:1.25rem;padding-top:1.25rem}.ui-section-footer__layout{column-gap:var(--ui-layout-gutter)}.ui-section-footer--copyright{margin-bottom:0;margin-right:auto}@media screen and (min-width:48rem){:root{--ui-typography-h1:2.1875rem;--ui-typography-h2:1.75rem;--ui-typography-h3:1.4375rem;--ui-typography-p:1.125rem;--ui-typography-s:.875rem;--ui-typography-margin-body:1.25rem;--ui-layout-container:4.25rem;--ui-layout-gutter:1.5rem;--ui-gap-content:3rem}.ui-layout-column-center,.ui-layout-container{margin-left:auto;margin-right:auto}.ui-layout-grid-3{column-gap:var(--ui-layout-gutter);grid-template-columns:repeat(2,1fr);justify-items:center}.ui-layout-grid-3 div:last-of-type{left:calc(50% + (var(--ui-layout-gutter)/ 2));position:relative}.ui-layout-column-4{width:calc((var(--ui-layout-grid) * 4) + (var(--ui-layout-gutter) * 3))}.ui-layout-column-6{width:calc((var(--ui-layout-grid) * 6) + (var(--ui-layout-gutter) * 5))}.ui-section-header{padding-bottom:2rem;padding-top:2rem}.ui-section-content{padding-bottom:3rem}.ui-section-content--icon{height:4rem;width:4rem}.ui-section-footer{padding-bottom:2rem;padding-top:2rem}}@media screen and (min-width:64rem){:root{--ui-layout-container:0}a{transition:all 250ms ease}a:not(.ui-component-button):hover{color:var(--ui-color-typography-body)}.ui-layout-container{width:60rem}.ui-layout-grid-3{grid-template-columns:repeat(3,1fr)}.ui-layout-grid-3 div:last-of-type{position:static}}@media screen and (min-width:75rem){:root{--ui-typography-h1:2.75rem;--ui-typography-h2:2.1875rem;--ui-typography-h3:1.75rem;--ui-typography-h4:1.4375rem;--ui-typography-margin-heading:1rem;--ui-typography-margin-body:1.75rem;--ui-layout-grid:4rem;--ui-layout-gutter:2rem;--ui-gap-content:4rem}.ui-text-intro{font-size:var(--ui-typography-h4)}.ui-layout-container{width:70rem}.ui-section-header{padding-bottom:3rem;padding-top:3rem}.ui-section-content{padding-bottom:5rem;padding-top:7.5rem}.ui-section-content--icon{height:5rem;margin-bottom:1.125rem;width:5rem}.ui-section-close{padding-bottom:7.5rem;padding-top:7.5rem}.ui-section-footer{padding-bottom:3rem;padding-top:3rem}}:root{--material-color-yellow-50:#fffde7;--material-color-yellow-100:#fff9c4;--material-color-orange-500:#ff9800;--material-color-orange-600:#fb8c00;--base-background:#fff;--base-color:#333;--base-color-lighter:#777;--base-color-muted:#999;--yellow-background:var(--material-color-yellow-100);--yellow-background-lighter:var(--material-color-yellow-50);--orange-background-dark:var(--material-color-orange-500);--orange-background-dark-active:var(--material-color-orange-600);--hatena-color:#01a5df;--base-font:-apple-system,BlinkMacSystemFont,Helvetica Neue,Yu Gothic,YuGothic,Verdana,Meiryo,M+ 1p,sans-serif;--ui-gap-content:2em}.ui-text-note{color:var(--base-color-muted)}.ui-section-header__layout img{display:inline-block;width:24px;height:24px;vertical-align:middle}.ui-section-content{padding-top:2.5em;padding-bottom:3.5rem}.ui-section-header{padding-top:2rem;padding-bottom:1rem}.ui-component-form{border-radius:0;grid-template-columns:auto minmax(0,1fr) auto}.ui-component-form .ui-component-button{border-radius:0;background:var(--orange-background-dark);border-color:var(--orange-background-dark)}.ui-component-form .ui-component-button.active{background:var(--orange-background-dark-active);border-color:var(--orange-background-dark-active)}@media screen and (min-width:48rem){.ui-layout-grid-3 div:last-of-type{left:0}}@media screen and (min-width:75rem){.ui-layout-grid-3{grid-template-columns:repeat(4,1fr)}}.ui-typography-heading{text-align:left}.ui-typography-heading small{color:var(--base-color-muted)}img{color:var(--base-color-muted)}.ui-section-header__layout .ui-section-header__title{display:inline-block;line-height:22px;vertical-align:middle;font-weight:700;font-size:1.3em;color:var(--base-color)}.ui-top-section{padding-bottom:2em}.ui-component-form__label{margin-left:.2em}.ui-component-form__label img{width:32px;height:32px}.ui-component-form__label span{font-weight:700}.ui-top-section .ui-text-note{margin-bottom:.6em}.ui-top-section .ui-top-section__subscribe{margin-top:.3em;display:flex;gap:.5em}.ui-top-section .ui-top-section__subscribe img{height:37px;width:auto}.ui-section-nav__layout{justify-content:start}.ui-section-nav__link{font-weight:700;margin-right:1.5em;padding:.5em 0;border-bottom:2px solid transparent;color:var(--base-color-muted)}.ui-section-nav__link--active{color:var(--base-color);border-bottom-color:var(--base-color)}.ui-section-content__feed-date-heading{text-align:left;font-size:1.2em;color:var(--base-color-lighter);margin-top:1em;margin-bottom:1em;padding:.4em .3em;border-bottom:1px solid var(--base-color-lighter);position:sticky;top:0;z-index:1;background-color:var(--yellow-background-lighter)}.ui-section-feed{background:var(--yellow-background-lighter)}.ui-section-feed .ui-layout-grid{align-items:flex-start}.ui-section-feed .ui-text-note{text-align:left;font-size:.9em}.ui-container-feed{text-align:left;margin-top:1em;margin-bottom:2em;justify-items:left}.ui-container-feed.ui-container-feed--hot{margin-top:2em}.ui-feed-item{display:grid;color:var(--base-color);grid-template-columns:130px 1fr;align-content:start;grid-gap:0 0.5em}.ui-feed-item .ui-feed-item__og-image img{width:100%;height:auto;max-height:7em;object-fit:contain;object-position:center top}.ui-feed-item .ui-feed-item__title{font-weight:700;font-size:.9em;-webkit-line-clamp:3;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden;word-break:break-all}.ui-feed-item .ui-feed-item__title:hover{text-decoration:underline}.ui-feed-item .ui-feed-item__title:visited{color:var(--base-color-lighter)}.ui-feed-item .ui-feed-item__hatena-count{margin:.1em 0;font-size:.7em}.ui-feed-item .ui-feed-item__hatena-count img{display:inline;width:1.25em;height:1.25em;vertical-align:middle}.ui-feed-item .ui-feed-item__hatena-count span{color:var(--hatena-color);font-weight:700;vertical-align:middle}.ui-feed-item .ui-feed-item__blog-title{margin:.3em 0;font-size:.75em}.ui-feed-item .ui-feed-item__blog-title--link:hover{text-decoration:underline}.ui-feed-item .ui-feed-item__summary{font-size:.75em;margin:.3em 0;word-break:break-all;overflow:hidden;-webkit-line-clamp:2;-webkit-box-orient:vertical;display:-webkit-box;color:var(--base-color-muted)}.ui-feed-item .ui-feed-item__date{color:var(--base-color-muted);font-size:.7em}@media screen and (min-width:48rem){.ui-feed-item{display:block}.ui-feed-item .ui-feed-item__og-image{display:block}.ui-feed-item .ui-feed-item__og-image img{height:9em;max-height:9em}.ui-feed-item .ui-feed-item__title{margin-top:.5em}}@media screen and (min-width:75rem){.ui-feed-item .ui-feed-item__og-image img{height:8em;max-height:8em}}.ui-section-blog{background:var(--yellow-background-lighter)}.ui-container-blog{text-align:left;margin-top:2em}.ui-blog{display:grid;color:var(--base-color);grid-template-columns:130px 1fr;align-content:start;grid-gap:0 0.5em}.ui-blog .ui-blog__og-image img{width:100%;height:auto;max-height:7em;object-fit:contain;object-position:center top}.ui-blog .ui-blog__title{display:block;font-weight:700;word-break:break-all}.ui-blog .ui-blog__title:hover{text-decoration:underline}.ui-blog .ui-blog__link{display:block;font-size:.7em;word-break:break-all;overflow:hidden;margin:.2em 0}.ui-blog .ui-blog__link:hover{text-decoration:underline}.ui-blog .ui-blog__description{font-size:.75em;margin:.3em 0;word-break:break-all;overflow:hidden;-webkit-line-clamp:2;-webkit-box-orient:vertical;display:-webkit-box;color:var(--base-color-muted)}.ui-blog .ui-blog__date{color:var(--base-color-muted);font-size:.7em}@media screen and (min-width:48rem){.ui-blog{display:block}.ui-blog .ui-blog__og-image{display:block}.ui-blog .ui-blog__og-image img{width:auto;height:9em;max-height:9em}.ui-blog .ui-blog__title{margin-top:.5em}}@media screen and (min-width:75rem){.ui-blog .ui-blog__og-image img{width:auto;height:8em;max-height:8em}}.ui-container-blog-summary{text-align:left;margin-bottom:2em}.ui-blog-summary .ui-blog-summary__link{display:block;word-break:break-all;overflow:hidden;margin:.2em 0}.ui-blog-summary .ui-blog-summary__link:hover{text-decoration:underline}.ui-blog-summary .ui-blog-summary__description{margin:.3em 0;word-break:break-all;color:var(--base-color-muted)}
</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-CNNNTL0NB3"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-CNNNTL0NB3")</script><title>sitateru tech blogのフィード｜企業テックブログRSS</title></head><body><header role="banner" class="ui-section-header"><div class="ui-layout-container"><div class="ui-section-header__layout ui-layout-flex"><a href="https://yamadashy.github.io/tech-blog-rss-feed/" role="link" aria-label="#"><img src="../../images/icon.png" alt="サイトロゴ" loading="lazy" decoding="async" width="96" height="96"> <span class="ui-section-header__title">企業テックブログRSS</span> </a><a href="https://github.com/yamadashy/tech-blog-rss-feed/" role="link" aria-label="#"><img src="../../images/github-mark.png" alt="GitHubロゴ" loading="lazy" decoding="async" width="96" height="96"></a></div></div></header><main role="main"><nav class="ui-nav"><div class="ui-layout-container"><div 
class="ui-section-nav__layout ui-layout-flex"><a class="ui-section-nav__link" href="../../">フィード</a> <a class="ui-section-nav__link" href="../../hot/">人気フィード</a> <a class="ui-section-nav__link" href="../../blogs/">ブログ一覧</a></div></div></nav><section class="ui-section-content ui-section-feed"><div class="ui-layout-container"><h2 class="ui-typography-heading">sitateru tech blog</h2><div class="ui-container-blog-summary"><div class="ui-blog-summary"><a class="ui-blog-summary__link" href="https://tech-blog.sitateru.com/">https://tech-blog.sitateru.com/</a><p class="ui-blog-summary__description">シタテルの技術やエンジニアの取り組みを紹介します。</p></div></div><h3 class="ui-typography-heading">フィード</h3><div class="ui-section-content--feature ui-layout-grid ui-layout-grid-3 ui-container-feed ui-container-feed--no-image"><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/12/ghcr-public.html"><img src="../../images/alternate-feed-image.png" loading="lazy" 
decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/12/ghcr-public.html">GitHub Container Registryに公開リポジトリを作ってみた</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
みなさんはコンテナイメージはどこに置いているでしょうか。 シタテルでは「基本はECR、GCPで利用するイメージはGCR」というまあ普通な構成になっています。 ですがこの度、「せっかく作ったし公開しておいてもいいかな」というコンテナイメージの置き場としてGHCRを使い始めました。 GHCRとは コンテナレジストリの利用 - GitHub Docs GHCRはGitHub Container Registryの頭文字で、GitHub上でいろいろなパッケージを公開できるGitHub Packagesの一機能といったところでしょうか。 DockerfileをGitHubで管理するならGitHub上でイメージ配布まで完結するわけですね。 料金ですが、パブリックなパッケージについては無料となってます。今回のニーズにはちょうどいいですね。 About billing for GitHub Packages - GitHub Docs イメージのpull/push等は ghcr.io/&lt;OWNER&gt;/&lt;IMAGE_NAME&gt;:&lt;tag&gt; という表記になります。(OWNERはGitHubのユーザー名やorganization名になります) push前などに認証する場合は以下のようになります。 write:packages スコープを持つアクセストークンを作っておく $ echo &lt;token&gt; | docker login ghcr.io -u USERNAME --password-stdin リポジトリ作成・push というわけで、organizationのPackagesにコンテナイメージをアップロードして公開してみましょう。 上記のコマンドで認証したら、好きなイメージ名とタグ名をつけてpushするだけです。 $ echo $GH_TOKEN | docker login ghcr.io -u sitateru --password-stdin $ docker pull hello-world:latest $ docker tag hello-world:latest ghcr.io/sitateru/hello-world:latest $ docker push ghcr.io/sitateru/hello-world:latest アップロードしたパッケージ...
</div><div class="ui-feed-item__date" title="2021-12-22 09:04:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/10/efs-persistentvolume-eks.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/10/efs-persistentvolume-eks.html">Amazon EFSを使ってEKSに永続ボリュームを導入した</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
AWS EKSで動かしているアプリケーション用にEFSを使って永続ボリュームを用意してみたので、その方法をまとめてみようと思います。 とあるテスト用Kubernetes環境でMySQLのイメージを使ってデータベースを動かしているのですが、何かの拍子にpodが一旦削除などされてしまうとデータベースの中身のデータが全て無くなってしまいます。 そこで永続ボリュームを確保しておいて、MySQLデータ用のディレクトリをマウントしたボリュームにすればOKというわけです。 手順はほぼこのドキュメントどおりですが、一部変えないと動かなかった箇所があるのでその点も触れつつ書いてみようと思います。 Amazon EFS CSI ドライバー ドキュメントに従っても動かないよ！という件のissueはこちら。 Missing permission in the example IAM policy file · Issue #489 · kubernetes-sigs/aws-efs-csi-driver · GitHub また、今回やってみた環境は以下のようになっています。 Kubernetes v1.21 EKSプラットフォーム eks.2 EFS CSI ドライバー v1.3.4 Amazon EFS CSI ドライバー まずはIAMポリシーを作成します。 { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;elasticfilesystem:DescribeAccessPoints&quot;, &quot;elasticfilesystem:DescribeFileSystems&quot;, &quot;elasticfilesystem:DescribeMountTargets&quot;, &quot;ec2:DescribeAvailabilityZones&quot; ], &quot;Resource&quot;: &quot;*&quot; }, { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;elasticfilesystem:CreateAccessPoint&quot; ], &quot;Resource&quot;: &quot;*&quot;, &quot;Condition&quot;: { &quot;StringLike&quot;: { &quot;aws:RequestTag/efs.cs...
</div><div class="ui-feed-item__date" title="2021-10-14 08:06:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/08/aws-app-mesh-on-eks-3.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/08/aws-app-mesh-on-eks-3.html">AWS App Mesh をEKSで試してみた（仮想ゲートウェイ）</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
前回に続き、EKS上でのAWS App Meshをやっていきます。 今回は、仮想ゲートウェイです。 ゲートウェイがあれば、メッシュ上のリソースにメッシュ外のpodやWebなどからアクセスできるようになります💁‍♂️ 今回の内容もドキュメント等いまいち見つからなかったので正確さなどは怪しいところがありますがご了承ください🙇‍♂️ Virtual gateways - AWS App Mesh 仮想ゲートウェイ作成 まずは仮想ゲートウェイとそのルートを作成します。 リスナーのポートは後で作るゲートウェイの実体と番号を合わせれば何番でもよさそうです。ルートは、全てのリクエストを前回作った仮想サービス(svc-v)へ流すよう指定してみました。 apiVersion: appmesh.k8s.aws/v1beta2 kind: VirtualGateway metadata: namespace: mesh-test name: gateway-v spec: namespaceSelector: matchLabels: mesh: mesh-1 podSelector: matchLabels: for: gateway listeners: - portMapping: port: 8088 protocol: http connectionPool: http: maxConnections: 1024 logging: accessLog: file: path: /dev/stdout --- apiVersion: appmesh.k8s.aws/v1beta2 kind: GatewayRoute metadata: namespace: mesh-test name: gateway-v-route-v spec: httpRoute: action: target: virtualService: virtualServiceRef: name: svc-v match: prefix: / ゲートウェイ作成 ゲートウェイの実体となる、envoyイメージのコンテナと type: LoadBalancer な サービスを作成します。 envoyのcontainerPortとサービスのt...</div><div 
class="ui-feed-item__date" title="2021-08-27 09:19:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/06/aws-app-mesh-on-eks-2.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/06/aws-app-mesh-on-eks-2.html">AWS App Mesh をEKSで試してみた（仮想ルーター、仮想サービス）</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
前回に続き、EKS上でのAWS App Meshをやっていきます。 今回は、仮想ルーターと仮想サービスです。 前回作った仮想ノードにアクセスするには仮想ルーターか仮想ゲートウェイが必要になるので、いよいよメッシュができていきます💪 あまりしっかり説明されたドキュメントが見つからず経験ベースな部分が多いので、正しい説明になっているかどうか怪しい部分もありますがご了承ください🙇‍ 仮想ルーター作成 仮想ノードへトラフィックを振り分ける仮想ルーターを作成します。 振り分け先は weightedTargets の virtualNodeRef.name で仮想ノード名を指定します。 プロトコルはHTTPにしましたが、他にもGRPC, HTTP2, TCPが設定できるようです。 apiVersion: appmesh.k8s.aws/v1beta2 kind: VirtualRouter metadata: namespace: mesh-test name: vrouter-1 spec: listeners: - portMapping: port: 80 protocol: http routes: - name: route-1 httpRoute: match: prefix: / action: weightedTargets: - virtualNodeRef: name: vnode-1 weight: 1 - virtualNodeRef: name: vnode-2 weight: 1 仮想サービス用サービス作成 仮想サービスの実体にするserviceを作成します。 selecter は、仮想サービスを介してアクセスする先のpodが全て含まれるように指定する必要があるみたいです。 今回の例だと、仮想サービス → 仮想ルーター(vrouter-1) → 仮想ノード(vnode-1, vnode-2) というトラフィックの流れになるので、vnode-1とvnode-2の実体になるpodに app: sample1 のラベルをつけてあります。 apiVersion: v1 kind: Service metadata: name: svc-v namespace: mesh-test labels:...</div><div 
class="ui-feed-item__date" title="2021-06-17 08:55:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/06/aws-app-mesh-on-eks-1.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/06/aws-app-mesh-on-eks-1.html">AWS App Mesh をEKSで試してみた（準備～仮想ノードまで）</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
突然ですが、AWS App Meshは皆さんお使いでしょうか？ AWS製のサービスメッシュ構築サービスですね。 サービスメッシュといえばIstioが有名ですが、AWS App MeshはAWS製だけあってEKSはもちろんEC2やECSのインスタンス・コンテナもメッシュに組み込むことができるのが強みという印象です。 そんなApp MeshをEKS上でいろいろと実験してみたので、自分の理解の反芻のためにもまとめてみたいと思います。 試した環境は kubernetes 1.20, App Meshコントローラ 1.3.0 でした。 準備 ドキュメントに従ってコントローラをインストールします。 Getting started with AWS App Mesh and Kubernetes - AWS App Mesh 手順はドキュメントの通りなのでここでは書きませんが、完了するとappmesh-systemネームスペースでコントローラのポッドができていました。 $ kubectl get pod -n appmesh-system NAME READY STATUS RESTARTS AGE appmesh-controller-6c55b46558-8s363 1/1 Running 0 1d mesh作成 メッシュを作成します。 egressFilter はメッシュ内部から外部へのアクセスを許可するかどうかですね。許可しない場合はDROP_ALLにします。 namespaceSelecter も何でもいいので書いておきましょう。 apiVersion: appmesh.k8s.aws/v1beta2 kind: Mesh metadata: name: mesh-1 spec: egressFilter: type: ALLOW_ALL namespaceSelector: matchLabels: mesh: sitateru-mesh namespace作成 メッシュのリソースを配置するネームスペースを宣言します。 上のMeshで指定した namespaceSelector とラベルを合わせておきましょう。 App Meshの機能を使うにはappmesh.k8s.aws/sidecarInjectorWebhook をenabl...</div><div 
class="ui-feed-item__date" title="2021-06-03 09:06:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/04/questionnaire-desktop-app.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/04/questionnaire-desktop-app.html">シタテル開発陣に聞いてみた：便利なデスクトップアプリ</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
今回はちょっと新企画として、シタテルの開発部にアンケートをとって記事を書いてみようかと思います。 第1回は、「日々の開発業務で便利なデスクトップアプリを聞いてみた」です😁 初めての試みということもあり、まずはジャンル問わずで募集してみました。 早速コメントとともにまとめてみたいと思います。 Sidekick 説明 Webブラウザ＋アプリまとめアプリ 特にいいと思うところ Chromiumベースのブラウザとアプリ集約が一体化したようなアプリです。 縦にアプリ、横にブラウザタブが並んで管理できるので1ウィンドウで一覧性よく収まります。 1passwordなどのブラウザ拡張機能が使えるのがうれしいところで、StationやBiscuitなどとの一番の差別化ポイントだと思っています。 Sequel Ace 説明 mysqlのGUIツール Workbenchより軽快な気がする Alacritty 説明 クロスプラットフォームのターミナルエミュレータ 特にいいと思うところ GPUによる高速なレンダリング YAMLファイルで設定できて、別のOSでも同じ設定が使えて便利 RubyMine 説明 JetBrains製のRubyに特化したIDE 特にいいと思うところ 補完、コードジャンプ、検索など開発に必要な機能が特別な設定無しですぐ使える GitUp 説明 とてもシンプルなGUIのGitクライアント 特にいいと思うところ ツリーが見やすい 基本的なgitの操作はショートカットキーで素早くできる （あまり複雑な機能はない代わりに）見た目がシンプル いかがでしょうか。気になるものがあれば、ぜひリンクをチェックしてみてください🤲 実際聞いてみたところ、「これといったデスクトップアプリはあまり使っていない」「VSCodeでたいていのことができてしまう」といった感想が多く、思ったほど集まりませんでした🤔 コマンドラインツールやWebアプリ・Webサービスのほうがいろいろあるという声があったので、気を取り直して次回はそのあたりを集めてみようと思います！</div><div class="ui-feed-item__date" title="2021-04-23 08:35:00">1年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/02/introduce-volta.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/02/introduce-volta.html">Node.jsのバージョン管理をVoltaに統一したわけ</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
Node.jsを使っていれば永遠のテーマである(?)バージョン管理ですが、皆さんはどのようにしているでしょうか。 今更ながら、ローカル環境で使用するバージョン管理を原則としてVoltaに統一する運びになったので、その背景などを書いてみたいと思います。 今までは特にバージョン管理ツールを標準で決めておらず、個人やチームでそれぞれ好きなものを使っているような状態でした。 それはそれで大きく困るようなことはなかったのですが、先日多くのリポジトリにざっといくつかの設定・アップデートをして回るようなタスクがあって話が変わりました。 それぞれのリポジトリで使っているNodeのバージョンをどこからか見つけてきて切り替えする作業を1日に何度もやるのはやはり効率が悪いしストレスですね。 バージョン管理ツールを決めて全社標準で設定してもらわないことには、私が 😇 してしまう・・・ ということで何のツールをツールを使うか検討を始めました。 今回の悩みを解消するためには、要件はこんなところです。 設定しておけばカレントディレクトリに応じて自動でNodeのバージョンが切り替わる 設定したバージョンをVCSに記録できる npmのバージョンも記録して自動切換えできる ちなみに最後の条件はnpmのバージョン7がもう一般リリースされているので出てきたものです。 npm 7 is now generally available! - The GitHub Blog それまでのバージョン6とは機能面の破壊的変更とlockファイルの変更などがあるので、これも併せてバージョン管理しておきたくなったわけですね。 さて結論ですが、Voltaを使うことにしました。 Volta - The Hassle-Free JavaScript Tool Manager ある程度メジャーなツールで上の要件を満たすものとなるとVoltaしかなかったためです。 使うのも簡単でいい感じですね。 Voltaの使い方については詳しい記事が各地にあるのでここではあまり書きませんが、例えばNode 14, npm 6を使うなら $ volta install node@14 npm@6 $ volta pin node@14 npm@6 とすると package.json にバージョンが書き込まれます。 { ......</div>
<div class="ui-feed-item__date" title="2021-02-26 04:35:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/01/dependabot-docker-tag.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/01/dependabot-docker-tag.html">GitHub dependabot でDockerタグをバージョン指定する</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
寒い日が続きますね。 ところで皆さんはGitHubのdependabotは使っていますでしょうか？ リポジトリをスキャンして、使っているライブラリやパッケージの脆弱性をお知らせしてくれるサービスですね。 依存関係を自動的に更新する - GitHub Docs そのdependabotでちょっとした問題を調べて解決したので記録しておこうと思います。 題して「特定のDockerタグを無視する設定の書き方」です。 dependabotの概要や初期設定などはこの記事ではちょっと飛ばしますのでご了承ください🙇‍ dependabotはDockerタグにも対応していて、脆弱性対応された新しいバージョンタグがある場合はそれを出すようになっています。 例えばリポジトリの docker/Dockerfile をスキャン対象にする場合、コミットしておく設定ファイル .github/dependabot.yml はこのようになります。 version: 2 updates: - package-ecosystem: &quot;docker&quot; directory: &quot;/docker&quot; さて、基本的にはdependabotはメジャーバージョンアップも含めて最新バージョンにアップデートさせるように動作するようです。 そのため、Dokerfileで node:14.x.x イメージを使っている場合 このように node:15 系にアップデートしなよ！というPRが作成されるのです。 でもNode.jsはバージョン14はLTSで15はLTSじゃない・・・更新するなら14系の最新にしてほしい！ というわけで、「Dockerタグの特定バージョンを無視する設定」を調べて入れてみました。 依存関係の更新の設定オプション - GitHub Docs こちらのドキュメントによると、あるバージョンへの更新を無視するためにはdependabot.ymlにそのバージョンを明記すればいいのですが、 範囲を定義する場合は、パッケージマネージャーの標準パターンを使用します Dockerタグの標準パターンって何だ・・・？🤔 結局わからなかったのでソースを見てみたところ、判定しているのはおそらくこのあたり。 dependabot-core/update_checker.rb at main · dependab...
</div><div class="ui-feed-item__date" title="2021-01-15 08:07:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/11/aws-ecr-lifecycle-policy.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/11/aws-ecr-lifecycle-policy.html">AWS ECRのライフサイクルポリシーを設定して自動クリーンアップ</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
今回は軽く、AWS ECR (Elastic Container Registry) の小ネタです。 AWSでコンテナを使って何かする場合ECRにコンテナイメージを保存しておくことが多いと思いますが、日ごろからイメージをよくビルド＆プッシュしているとどんどんイメージが増えていきますね。 イメージサイズがものすごく大きいとかでなければそれほど料金を食うわけでもないのですが、まず使わない古いイメージをずっと保存しておくこともないよなーと思ったのでそのあたりを設定してみました。 ECRではライフサイクルポリシーという機能があり、いろいろな条件を定めてイメージを自動クリーンアップすることができるんですね。 Amazon ECRのライフサイクルポリシーでコンテナイメージのクリーンアップ | Amazon Web Services ブログ 設定できる条件は タグ イメージ数 プッシュされてからの経過日数 を組み合わせることができます。 今回は、「タグが latest ではない」かつ「プッシュされて90日以上」の条件に合うイメージを削除するポリシーを設定してみました。 AWSコンソールで設定する場合は、ECRのコンソールでリポジトリを選択して左のメニューの Lifecycle Policy をクリックすると設定画面があります。 「テストルールの編集」ボタンを押すとポリシーを適用した結果が確認できる（実際に保存されているイメージには何もしない）テスト用ページに移動するので、まずはそこで試してみるのがいいですね。 さて、ライフサイクルポリシーは「ルール」を優先順位つきで好きな数設定することで構成します。ルール作成画面はこうなっていて、一致条件は「イメージをプッシュしてから」「次の数値を超えるイメージ数」が選べます。 今回作りたい条件は「タグが latest ではない」かつ「プッシュされて90日以上」ということで、 タグ付け済(&quot;latest&quot;)、次の数値を超えるイメージ数(1) すべて、イメージをプッシュしてから(90日) という2つのルールを作ってこのようになります。 ルールを作ればあとは自動でそれに従ってイメージが毎日掃除されるので、とても楽ですね😊 ここまではコンソールで操作してきましたが、リポジトリが多い場合やコンソール面倒だと言う場合はもちろんC...
</div><div class="ui-feed-item__date" title="2020-11-12 09:15:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/09/gcp-billing-alert-to-slack.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/09/gcp-billing-alert-to-slack.html">GCPの料金アラートをSlackに出してみる</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
AWSやGCPの料金、たまに気になりますよね。 そういえば今月どれくらい料金食ってるんだ？と思ったとき、もちろん各サービスのコンソールで課金管理のページを開けば確認できますね。 が、日常的にはお知らせが届くほうが簡単ですむよね、ということでslackに通知をさせてみました。 AWSは簡単だったのですがGCPはちょっと手間だったのでまとめておきたいと思います。 まあエンジニアとしては課金の具合を気にせず開発に集中できれば一番いいのですが、現実には会社の予算とかいろいろありますし私は課金周りの把握をする役回りもあるので、これはやっておきたいところです。 1. Pub/Subトピック作成 まずは適当なプロジェクトを用意し、Pub/Sub でトピックを作成します。 2.GCPで予算の作成 次は予算の作成です。GCPのメニューから「お支払い」→「予算とアラート」と進み、予算の作成をクリック。 予算と予算アラートの設定 | Cloud Billing | Google Cloud まずは料金を集計する対象を選択します。 プロジェクトやサービスを絞り込んだり、特定のラベルを付けたリソースだけを対象にすることもできます。 予算は設定された額に対して実際の課金額が達したら通知されるようになっています。設定額は、「自由に設定」と「先月の額」から選べるんですね。 ちなみに5000兆円は設定できませんでした🥺 最後に設定額の何％になった時点でアラート出すかのしきい値を設定します。実値or予測値で、パーセンテージは自由に設定できます。 あと、先ほど作成したPub/Subトピックを忘れずに接続しておきましょう。 3. Slack App作成 Slackに通知するために、Appを作成してトークンを発行します。 コスト管理の自動レスポンスの例 | Cloud Billing | Google Cloud https://api.slack.com/apps で Create New App をクリックし、適当なAPP名と導入したいワークスペース名を入力してアプリを作成します。 メニューの OAuth &amp; Permissions を開き、 Bot Token Scopes に chat:write スコープを追加します。 ページ上部の Install...</div><div 
class="ui-feed-item__date" title="2020-09-04 06:49:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/07/github-actions-self-hosted.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/07/github-actions-self-hosted.html">GCPでGitHub Actionsのセルフホストランナーを作った</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
朝野です。少し前の話ですが、GitHubの料金が全体的に値下げされましたね。 https://github.co.jp/pricing.html Teamプランは1ユーザーあたり4ドルになったのですが、さりげなく同時にGitHub Actionsの利用時間（organizationのプライベートリポジトリ全体で）が月3000分まで、と減ってしまいました 😥 (前は10000分) 以前の記事(GitHub ActionsとCypressでサイト監視してみる|sitateru tech blog)で紹介したようなCypressを使った監視をActionsで動かしていたので、月3000分は少ないなーと思って料金を見てみたところ・・・ https://github.co.jp/features/actions#pricing セルフホストはタダなのか！しかしセルフホストって何だ？🤔 ということでやってみました。 セルフホストランナーについて - GitHub Docs セルフホストランナーというのは、GitHub Actionsを実行するマシンのことです。自分の管理下にあるサーバーやPCでActionsが実行できちゃいます。前述のように、セルフホストランナーで実行する分にはGitHubに対して課金は発生しません。 ・・・おっ、ということはGCPの永久無料枠のCompute Engineインスタンスを使えばタダで回し放題やんけ！( ^ω^) Google Cloud の無料枠 | Google Cloud Platform の無料枠 と思ったのですが、先に結論を書きます、コンテナ上でCypressテストを実行するには無料枠の f1-micro では処理能力的に無理でした。もっと軽い処理なら足りるのかもしれませんが・・・ e2-micro ならなんとか動いたのでこれで良しとしましょう。 さて、セルフホストランナーをクラウド上のLinuxインスタンスで構築する手順に行きたいと思います。 セルフホストランナーの追加 - GitHub Docs organizationで使えるランナーを追加するには、 まずhttps://github.com/organizations/{organization名}/settings/actions で Add Runner をクリック。する...
</div><div class="ui-feed-item__date" title="2020-07-10 08:52:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/04/flood-element-load-testing.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/04/flood-element-load-testing.html">Flood Element でブラウザベースの負荷テスト</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
どうも朝野です。 少し前に負荷テストツールのFlood Elementというものを使ってみたので、紹介しようと思います。 まずはCLIをインストールします。npmかHomeBrewでインストールできます。 $ npm install -g @flood/element-cli $ brew install flood-io/taps/element CLIを使ってプロジェクトを作成、テストファイルを追加します。 $ element init $ element generate some-test.ts テストファイルにはブラウザ上での操作を書いていきます。elementはpuppeteerを利用しているので、書き方はかなりpuppeteerに近いですね。 googleのトップページにアクセスして&quot;flood element&quot;と検索するならこのようなコードになります。 import { step, TestSettings, By, Until } from &#39;@flood/element&#39; export const settings: TestSettings = { // userAgent: &#39;flood-chrome-test&#39;, loopCount: 10, screenshotOnFailure: true, clearCache: true, clearCookies: true, actionDelay: 1, stepDelay: 1, waitTimeout: 180 } export default () =&gt; { step(&#39;Sample&#39;, async browser =&gt; { await browser.visit(&#39;https://google.com&#39;) await browser.click(By.css(&#39;form input[type=&quot;text&quot;]&#39;)) await browser.sendKeys(&#39;flood element&#39;, Key.ENTER) await browser.wait(Until.elementIsVisible(By.css(&#39;div#search&#39;))) await browser.takeScreenshot() }) } ローカルで実行するときは $ elemen...
</div><div class="ui-feed-item__date" title="2020-04-30 08:38:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/03/tech-for-cypress-on-github-actions.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/03/tech-for-cypress-on-github-actions.html">Cypress on GitHub Actions のいろいろなテクニック</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
朝野です。 先日CypressとGitHubを使う記事を書いたのですが、今回はもう少し突っ込んだ話として、ActionsでCypressを使う上で引っかかったところなどをまとめてみたいと思います。 Cypressのテストが止まったままになる？？ Dockerコンテナ上でCypress(ブラウザはChrome)を実行していると途中で止まってしまうことがあります。 調べてみたところChromeの共有メモリが足りなくなっているようです。 そんなときは cypress/plugin/index.js にこの記述で直りました。 module.exports = (on, config) =&gt; { on(&#39;before:browser:launch&#39;, (browser, launchOptions) =&gt; { if (browser.name === &#39;chrome&#39;) { launchOptions.args.push(&#39;--disable-dev-shm-usage&#39;) } return launchOptions }) } Chromeの起動時に --disable-dev-shm-usage オプションをつけているのですが、これによって共有メモリファイルを /tmp 以下に配置するので充分な容量が確保できるということだそうです。 :hover CypressにはCSSの:hover状態を発生させる機能が無いようです🙄 hover | Cypress Documentation If cy.hover() is used, an error will display and redirect you to this page. Cypressでは非表示状態の要素はクリックなどの操作ができないのですが、じゃあ:hover時に表示される要素をクリックしたいときはどうするの？という話になりますね。 上記のドキュメントでは cy.get(&#39;.hidden&#39;).invoke(&#39;show&#39;).click() cy.get(&#39;.hidden&#39;).click({ force: true }) という方法が紹介されています。 ちょっと試したところ invoke(&#39;show&#39;) はうまくいかなかったのですが click({ force: true }) はできたので、...
</div><div class="ui-feed-item__date" title="2020-03-19 03:46:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/02/github-actions-cicdcircleciactions-e2e.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/02/github-actions-cicdcircleciactions-e2e.html">GitHub ActionsとCypressでサイト監視してみる</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは、朝野です。 皆さんはGithub Actions使ってますか？ シタテルではCI/CDはCircleCIを使っているのですが、せっかくなのでActionsも何かに使いたいなあと思って、簡単なサイト監視のようなものを作ってみたのでそのことを書いてみます。 監視に使うのは、E2EテストフレームワークのCypressです。 ブラウザの自動化やテスト用に使っている方も多いのではないかと思います。 サクッと動かすなら テストコードを書いて cypress/integration/ ディレクトリに入れておく npmでcypressをインストール $ npx cypress run で実行 と、なかなかお手軽です。 たとえば https://sitateru.com/ のページが表示されることをチェックするコードをCypressで書くとこのようになります。 describe(&#39;Check page&#39;, function() { it(&#39;top&#39;, function() { // URLを開く cy.visit(&#39;https://sitateru.com/&#39;) // ページタイトルをチェック cy.title().should(&#39;eq&#39;, &#39;sitateru - シタテル - | その服は、つくれる。&#39;) // ページ内に特定の文字列があることを確認する cy.contains(&#39;かんたん無料登録&#39;) // CSSセレクタを使って、要素が存在することを確認する cy.get(&#39;.top-main-visual&#39;).should(&#39;exist&#39;) }) }) また、ログイン操作であればこんなふうになります。 describe(&#39;Login&#39;, function() { it(&#39;login&#39;, function() { cy.visit(&#39;https://atelier.sitateru.com/login&#39;) // フォームに入力 cy.get(&#39;#email&#39;).type(Cypress.env(&#39;LOGIN_EMAIL&#39;)) cy.get(&#39;#password&#39;).type(Cypress.env(&#39;LOGIN_PASSWORD&#39;)) // ログインボタンをクリック cy.get(&#39;input[type=&quot;submit&quot;]&#39;).c...
</div><div class="ui-feed-item__date" title="2020-02-05 09:18:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/12/advent-calendar-kubernetesnamespace.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/12/advent-calendar-kubernetesnamespace.html">安全にkubectl applyするコマンドを作った</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
どうも朝野です。 最近 本番環境でやらかしちゃった人 Advent Calendar が話題ですね。 私も楽しく読ませてもらっています。 かくいう私も先日、kubernetes環境で作成中のアプリケーションを間違って別アプリケーション用のnamespaceにデプロイしてしまうという事故をやってしまいました😇 何をどうミスしたかというと、 新しく作るnamespace以下にkubectl applyでアプリケーションをデプロイしようとした 対象のyamlファイルは別プロジェクトのソースファイルをコピーして作ったものだった yaml内に書かれているapply先namespaceが別プロジェクトのnamespaceのままだった ということだったのです。 普段kubernetes環境へのapplyは原則CircleCI内で行っているのですが、今回は環境構築中なアプリケーションだったので手動で実行しようとしていたのでした。 上書きしてしまったほうもデモ用環境のようなもので利用者もいなかったため、大事には至らなかったのは不幸中の幸いでした。 実行前に確認しなかった私が悪いのですが、これは何とかして防げるようにしたいなあということで、applyする前にyaml内のnamespaceをチェックしておかしかったら止める、というシェルスクリプトを作りました。 作るにあたっては以下のような前提があります。 環境の切り替え管理にkustomizeを使っている 各環境のyamlは k8s/overlays/{環境名} ディレクトリに置いて、kubectl apply -k k8s/overlays/{環境名}でデプロイ デプロイ先namespaceは {リポジトリ名}-{環境名} に統一する というわけで作ってみたのがこちら。 #!/bin/sh # check whether namespace is {repository}-{env} correctly or not kubectl kustomize $1 &gt; /dev/null 2&gt; /dev/null if [ $? != 0 ]; then /bin/echo &#39;usage: kubeapply [kustomize_dir]&#39; exit 1 fi PROCEED=0 REPOSITORY_NAME=$(git ...
</div><div class="ui-feed-item__date" title="2019-12-19 07:38:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/10/gasg-suite.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/10/gasg-suite.html">GASでG Suiteグループ追加をやってみた</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
どうも朝野です。 以前の記事で、作業を楽にするためにRPAを触ってみたという話を書いたのですが その関係の取り組みの一つとして現在Google Apps Script(GAS)でアカウント管理操作を集約・省力化するという作業を進めています。 Google Apps Scriptはご存知の方も多いと思いますが、Googleの様々なサービスと連携させて動かすことができるスクリプト言語です。 シタテルではG Suiteをバリバリ使っているので、アカウント管理システムもGASを中心として作っていこうと考えています。 そこで、まずはGASで何か作ってみる第1号として、ユーザーをグループに追加するフォームを作ってみました。 グループ追加はG Suiteの管理画面からできるのですが若干作業として面倒だったりするんですね。 というわけでまずはGoogleフォームを作成。 「追加するユーザー」「追加先グループ」の入力欄を作ります。 それからオプション設定の「メールアドレスを収集する」をチェック。 つづいて右上メニューから「スクリプトエディタ」を選択するとGASのオンラインエディタが開きます。 ここでソースコードを編集します。 今回のコードはこのようなものです。 var privilegedRespondent = [&#39;taro@sitateru.sample&#39;, &#39;jiro@sitateru.sample&#39;]; // グループ追加,フォーム送信時に実行 function addUserToGroup(event) { console.log(&#39;addUserToGroup()&#39;); var message = &quot;グループ追加フォームからの通知です\n\n&quot;; const respondent = event.response.getRespondentEmail(); if(privilegedRespondent.indexOf(respondent) === -1) { console.log(&#39;Respondent &#39; + respondent + &#39; not allowed&#39;); message += &#39;あなた( &#39; + respondent + &quot; )にはアカウントを作成する権限がありません\n&quot;; sendResult(respondent, messa...
</div><div class="ui-feed-item__date" title="2019-10-11 08:50:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/09/sqljson.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/09/sqljson.html">SQLをつかってJSONで格納されたデータを検索してみた</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは！ シタテルでエンジニアをしている建山です。 今回は、データベース（MySQL）にJSON形式で格納されているデータをSQLで検索する方法を紹介します。 シタテルでは、AWS上のデータベースに蓄積されたデータをredashというツールを使い、SQLでデータ抽出したあと、データ分析できるようになっています。 やりかた 今回はMySQLの たとえば、格納データが以下の2レコードあったとします。 {&quot;maxCount&quot;:1000,&quot;targets&quot;:{&quot;ladies&quot;:false,&quot;mens&quot;:true,&quot;kids&quot;:false,&quot;baby&quot;:false}} {&quot;maxCount&quot;:50,&quot;targets&quot;:{&quot;ladies&quot;:true,&quot;mens&quot;:false,&quot;kids&quot;:false,&quot;baby&quot;:false}} ここで、maxCountが50のデータを検索したいときは、 JSON_EXTRACTを使用し、以下のように抽出できます。（テーブル名：table_a、JSON格納カラム名：detail） select * from table_a where JSON_EXTRACT(detail, &#39;$.maxCount&#39;) = 50 targetsのladiesがtrueの検索をしたいときは、以下のようになります。 select * from tablename where JSON_EXTRACT(detail, &#39;$.targets.ladies&#39;) = true # 感想 このように、```$. のあとに、キーの名前を指定してあげれば、かんたんに、jsonが格納してあるカラムの中身を検索することができます。（表示の記述方法も同じ） 公式のドキュメントはこの辺あたりのようです。 https://dev.mysql.com/doc/refman/5.7/en/json.html 他にもいくつか関数があるようなので、いろいろ試してみたら、いいSQL+JSONライフが送れるかも知れません！ 簡単ではありましたが、ご紹介でした！
</div><div class="ui-feed-item__date" title="2019-09-09 03:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/09/rpa.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/09/rpa.html">RPA触ってみた</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
どうもお久しぶりです。シタテルの朝野です。 突然ですがRPAってご存知でしょうか？私は数週間前にまともに知りました🙄 &quot;Robotic Process Automation&quot; の略で、PC上での作業をソフトウェアロボットが行うよう自動化することです。 現在私のいるDevOpsチームでは単純な作業を自動化して時間と手間を節約できないかという取り組みを少しずつ進めています。 そんな中でRPAというものの存在を知り、簡単に無償で導入できるものを試してみたので、サンプルと共に紹介します。 今回やってみたサンプルは、シタテルの「マイアトリエ」をブラウザで開いてログインするというものです。 （※サンプル内のメールアドレスとパスワードはダミーの値です） Javascript for Automation MacOS Yosemite以降で使用可能なスクリプト言語です。 サンプルコードはこのようになります。 const DELAY = 3; const Chrome = Application(&quot;Google Chrome&quot;); const window = Chrome.windows[0]; const tab = Chrome.Tab({ url: &#39;https://atelier.sitateru.com/login&#39; }); window.tabs.push(tab); delay(DELAY); inputText(tab, &#39;email&#39;, &#39;sample@sitateru.sample&#39;); inputText(tab, &#39;password&#39;, &#39;sample_password&#39;); submit(tab); function inputText(tab, elementId, value) { tab.execute({ javascript: &quot;document.getElementById(&#39;&quot; + elementId + &quot;&#39;).value =`&quot; + value + &quot;`;&quot; }); } function submit(tab) { tab.execute({ javascript: &quot;document.forms[0].submit();&quot; }); } ブラウザ上での入力やクリックはjavascriptをブラウザ内で走らせることで行っています。 ...
</div><div class="ui-feed-item__date" title="2019-09-09 03:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/06/blog-post.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/06/blog-post.html">書評『進化的アーキテクチャ ―絶え間ない変化を支える』</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは、シタテルの茨木です。 社内の輪読会でオライリー『進化的アーキテクチャ ―絶え間ない変化を支える』を読みました。 琴線に触れた部分・キーワードを中心に簡単にご紹介したいと思います。 どういう本か・総評 システムの「変更しやすさ」（進化可能性）をいかにして追求し、また経年劣化させないか、というところに主眼を置いています。経年劣化から守る仕組みとして「適応度関数」という考え方を導入します。 具体的な手法や考え方は、継続的デリバリーやドメイン駆動設計などの知見を参照しており、これらの知見を俯瞰的にまとめた内容とも言えます。 個人的には、適応度関数を始めとした本書で導入される概念より、参照されている既存の概念（CI/CD、DDDやその他の設計プラクティス）の方が参考になりました。最近の設計や開発プラクティスを俯瞰する本として読むのもいいかもしれません。 適応度関数 アーキテクチャが満たしているべき要件（本書内では次元）を保護するもの。 循環的複雑度・ユニットテスト・監視・メトリクスといったシステム的・自動的に測定可能なものだけでなく、外部組織によるシステム監査などの人手による測定も包含する概念。 守るべき次元を定め、適応度関数として定義、測定し続けることで、外形的にアーキテクチャを保護する。保護することで、壊さずに変更し続けられることを担保する。 ちょっと理想論すぎるかなという印象もありますが、そういう捉え方もあるな、という感想です。 アーキテクチャの分類・マイクロサービス 本書では下記のような各アーキテクチャを対等に並べて、それぞれの歴史的背景や特性を、主に進化可能性の観点から整理しています。 モノリス（3層レイヤ化モノリス等を含む） イベント駆動アーキテクチャ SOA マイクロサービス サーバレス いわゆるレガシー・エンタープライズ感の強いEDAやSOAから、マイクロサービスまで、しっかり比較の土台に載せている点は非常に良いと思いました。 まあ、最終的にマイクロサービス推しであり、そこに多くの紙幅が割かれてはいますが… マイクロサービスのどういった特性が優れていて、他のアーキテクチャではその特性は何とトレードオフにされているのか、整理して理解することができただけでも本書を読んだ価値があったと思います。 モノリスを構築できないとき、なぜマイクロサービスがそ...
</div><div class="ui-feed-item__date" title="2019-06-03 03:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/05/blog-post.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/05/blog-post.html">プログラミング・ゲーム</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは。 シタテルでバックエンドエンジニアをしている熊谷です。 今日は、プログラミングを学べるゲームやアプリの紹介をしたいと思います。 まず1つ目は、「Swift Playgrounds」です。 これはAppleが出しているiPad用のアプリで、キャラクターを動かすなどのプログラミングを、ゲーム感覚で学ぶことができます。 アプリ自体は前からあったのですが、最近やっと少し触ることができました。 画面イメージとしては、こんな感じです。 自分はまだ少ししか触れていませんが、初級からだんだん難しくなっていくレッスン形式になっていて、プログラミングに慣れていない人でも入りやすいのではないかと思います。 公式のレッスンの他にもサードパーティのレッスンもあり、センサーやロボット、ドローンを扱うようなものもあるようです。 普段のプログラミングや設計からの気分転換にもなって、良いと思います。 もう1〜2個紹介しようと思いましたが、長くなりそうなので、続きは次回にしたいと思います。</div><div class="ui-feed-item__date" title="2019-05-08 03:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/04/with-tmux.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/04/with-tmux.html">同時に複数のマシーンで同じ操作をする with Tmux</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div
 class="ui-feed-item__summary">sitateruのエンジニア北爪です。 複数のシェルで同じ操作をしたい時ってないですか？ ログを一箇所に集めてないけど、アプリケーションサーバーが複数台ある 複数台同時にtopコマンドで負荷をまたはtailコマンドでログを調査したい など調査段階でAnsible, Fabやcapistranoで操作するほどではなく、複数のサーバーを同じようにインタラクティブに操作したいという要求はあるように思います。 今回は複数のシェルに対して、分割された画面をみなが同時に操作、そのコマンドラインの結果を参照することが可能です。 tmuxを風にいうと、一つのpaneに行うキーボード操作をそのpaneが存在しているWindow内すべてのpaneキーボード操作を同期することができます。 この機能は、tmuxの synchronize-panes 機能です。tmuxを使ってない人には導入する大きなメリットの一つになるのではないかとお思います。デフォルトです。 http://man.openbsd.org/OpenBSD-current/man1/tmux.1#synchronize-panes 使い方 1. tmuxを起動し、複数のpaneを作成がある状態で 2. tmuxにbindしてあるtmuxのprefixキーを入力した後で、 `:` を入力します (余談私は ctrl-t にしています） # act like GNU screen unbind C-b set -g prefix C-t 3. tmux用のコマンドが立ち上がるので、そこに、 set synchronize-panes onを入力します。 4. そうするとなんと！表示されているpane(分割した画面) に同じキーボード操作が入力されます 5. もう同期したくなくなったら、 set synchronize-panes off にて解除することが可能です。 以上です。</div><div class="ui-feed-item__date" title="2019-04-23 03:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://tech-blog.sitateru.com/2019/04/vuejsscoped-cssz-index.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/04/vuejsscoped-cssz-index.html">Vue.jsとScoped CSSとz-indexの話</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは、シタテルの茨木です。 突然ですが、scoped cssいいですよね scoped cssは、特にVue.jsにおいては、css設計のスタンダードと言っていいのではないかと思います。 BEM等の学習コストの高い手法を覚える必要がなく、「コンポーネント内でのみcssクラス名の一意性を確保すればいい *1」という、シンプルで管理しやすい設計指針を打ち立てることができ、実に理にかなった手法ですね。 プロジェクト全体でのcss命名規約の統制問題は依然としてありますが、コンポーネントベースでの設計手法自体がコンポーネントを書き捨てる運用と親和性があるため、そこまで大きな問題にはならないのかなと思います。 依然として残る考慮点 一方、scoped cssだけで、コンポーネント内にcss的な関心事を完全に閉じ込められるかというとそうではなく、当然ながら例外もあります。 最も代表的な例としては、cssの仕様上継承されてしまう属性ですね。 font-sizeなど、属性自体が子孫要素に継承されるものとして定義されていますので、セレクタレベルでscopedにしたところで、子孫要素への影響を避けることはできません。 まあこの辺は書いていても直感的に理解しやすいのでそこまで問題になりにくいのですが、個人的に危ないなと思うのは「z-index」「重ね合わせコンテキスト」です。 z-indexの管理 cssをざっくり理解したつもりになっているエンジニアが犯しがちな間違いの一つが、z-indexがグローバルだと思いこんでしまうことだと思います。 そう考えているエンジニアは、Vueプロジェクト全体で単純にコンポーネントごとのz-indexを管理することをを思いつきます *2。例えば、コンテキストメニューのコンポーネントはz-index1000番台、モーダルダイアログのコンポーネントはz-index500番台といった管理です。（モーダル上でコンテキストメニューを開くかもしれない。その場合はコンテキストメニューがモーダルの下に回り込んでほしくない、なんてことを考えているわけですね） この方式は重ね合わせコンテキストがページ内で1つであるうちは上手く機能しますし、ルール自体はおそらく間違いでもないです。 ただ、重ね合わせコンテキストに関する考慮を漏らしていると、「z-indexで勝っているはずな...
</div><div class="ui-feed-item__date" title="2019-04-16 03:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/04/blog-post.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/04/blog-post.html">地方活性化のイベントに参加してきました</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは、シタテルの藤本です。 イベントの参加のために久しぶりに東京に行きましたが、渋谷駅から出られなくなりそうになりました。 あらためてお上りさんには厳しい街であることを実感しました。 先日「スマホで見つける地方のしごと」というシンポジウムにパネラーとして 参加させていただきました。 内容を簡潔にすると「首都圏での離職と地方へUIJターンを希望する方と地方企業の マッチングを進めて地方を活性化していこう」というイベントでした。 200名以上の方が参加され、各者の熱いプレゼンもありここから少しづつ 地方へ人材が広がっていってくれるのではないかと感じることができたイベントでした。 そんなイベントについて簡単にレポートしてみたいと思います プレゼンター、パネラー プレゼンター、パネラーとして以下の方々が参加されていました。 求人サイト運営企業 地方自治体 商工会議所 地方への移住者（Uターン） イベントの大まかな流れ 以下の内容で２時間ほどのイベントでした。 厚生労働省からの本取組みにおける施策のついての説明 求人サイト運営企業からのプレゼン 地方自治体、商工会議所、移住者からのプレゼン パネルディスカッション 各者の主張について 各者の主張について個人的に印象的だったことについて書いていきます。 求人サイト運営企業 求人サイト運営企業の方からのプレゼンで印象に残ったのは以下の2点でした 転職は孤独であり寄り添うことに注力したい 転職は一般的になっている 転職は孤独であり寄り添うことに注力したい 転職にする時は非常に多くの「不安」と戦うことになると思いますが共有・共感者が少ないといった問題があり、そこに「賛成」と後押しすることで生き方を一緒に考えていこうといったものでした。 個人的には人材の流動性が高まることはいいことだと思っているので求人サイト側がこういったことを考えていただけるとありがたいなと思いました。 ちなみに弊社のBaseValueの一つに「よりそう」と言葉が定義されており、大きく以下の3つで構成されています。 リスペクトする 声を聴く 感動を与える 詳細が気になった方は以下を参照いただけると嬉しいです。 シタテルの目指す未来｜シタテル株式会社 転職は一般的になっている 転職をポジティブに捉えているのは全世代で５割以上とな...</div><div 
class="ui-feed-item__date" title="2019-04-08 07:17:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/03/javascript-4.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/03/javascript-4.html">初めて見るとぎょっとするかもしれない JavaScript の構文 4 選</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは！ エンジニアの諏訪です。シタテルでは主にフロントエンドを担当しています。 今日はフロントエンド制御のエンジンともいえる JavaScript に関する話題です。 1990 年代半ば Web 時代の幕開け (※) とともに誕生した JavaScript ── ほんとうの名前は ECMAScript というのだそうですが ── 今も昔も変わらずクライアント側での処理機構としては唯一無二の立ち位置を保ち続けてきました。 よく考えてみるとこれってとてもすごいことですよね！ ※ 余談ですが World Wide Web の誕生から今日 (2019.03.12) でちょうど 30 年だそうです。 さて、上で「今も昔も変わらず」と書きましたが JavaScript 自身はもちろん何度も進化を重ねてきています。 その中でも ES2015 (ES6) では多くの新しい構文が追加され、処理内容によっては従来よりも大幅にシンプルな書き方ができるようになりました。 新しい構文は便利なのですが、勉強を始めたての新人やレガシーなプログラマが初めて見るとびっくりするような記法も。 今日はそんなユニークな (ちょっとぎょっとする) 記法を４つピックアップしてみました。 ドット３つ ... JavaScript のコードで、３つ並んだドットを見たことがありませんか。 let array = [ 1, 2, 3 ] let result = [ 0, ...array ] こんなコードを初めて見た時は「・・・あれ〜？」と脳が一瞬フリーズしてしまうこと必至です。ちなみにだじゃれです。 こちらは スプレッド構文 (spread syntax) と呼ばれるもので、 ES2015 で導入された新しい記法です。 配列やオブジェクトの展開操作を楽にしてくれます。 展開操作って？ 大雑把に言うと Array や Object の外側の括弧を取り払って丸裸にします。 例えばこういうことです。さっきの Array の例だと： let array = [ 1, 2, 3 ] let result = [ 0, ...array ] console.log(result) // =&gt; [0, 1, 2, 3] Object の場合だと： let obj1 = { potato: 2, carrot: 3...
</div><div class="ui-feed-item__date" title="2019-03-12 03:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/03/good-project-award-2019.html"><img src="../../images/alternate-feed-image.png" loading="lazy" decoding="async" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/03/good-project-award-2019.html">Good Project Award 2019で最優秀賞をいただきました！</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは！シタテル株式会社UI/UXデザイナーの田仲です。 私が担当しているマイオペレーター（以下、マイオペ）という縫製工場の生産管理者向けのシステムが、「JBUG(ジェイバグ：Japan Backlog User Group)」が開催する『Backlog World 2019』内の『Good Project Award 2019』にて最優秀賞を獲得いたしました。 『Backlog World 2019』とは 株式会社ヌーラボの日本最大級のプロジェクト管理ツール”Backlog(バックログ)”のユーザーコミュニティである”JBUG(ジェイバグ)”が主催した、プロジェクト管理に関わる全ての方のための祭典です。 Backlog Worldとして2回目の今年は、「プロジェクトマネジメント×働き方改革」というテーマで、 数々のセッションやワークショップ、情報共有の場、Good Project Award(表彰イベント)などでプロジェクト管理に関する知見を相互に高め合うことを目的としています。 2019年1月26日(土)、秋葉原UDXにて開催されました。 https://backlogworld2019.jbug.info/ 『Good Project Award 2019』とは 2018年〜2019年に活動したプロジェクトの課題やそれに対するアクション、その結果得られたことのストーリーを通し、プロジェクトマネジメントのヒントが共有されることを目指したアワードです。 Backlog Worldイベント内コンテンツとして「Good Project Award 2019」というピッチコンテストが開催され、来場者投票と審査員の審査により、最も素晴らしいものを表彰します。 『Good Project Award 2019』への応募経緯 アワードの存在を知ったCTOの和泉さんから「だしてみたら？」ともちかけてもらったのがきっかけです。 マイオペは2018年の頭から立ち上げ開始し、7月ごろにリリースをしました。Backlogは使用していなかったのですが、応募条件に利用有無は問われていなかった、応募することにしました。 『Good Project Award 2019』に登壇するまで エントリーフォームより応募 2018年末頃に、プロジェクトの目的や結果、熱い想いを書きました。 エン...
</div><div class="ui-feed-item__date" title="2019-03-04 03:00:00">3年前</div></div></div></div></div></section></main><footer role="contentinfo" class="ui-section-footer"><div class="ui-layout-container"><div class="ui-section-footer__layout ui-layout-flex"><p class="ui-section-footer--copyright ui-text-note"><a class="ui-text-note" href="https://github.com/yamadashy/"><small>@yamadashy</small></a></p><a href="https://github.com/yamadashy/tech-blog-rss-feed/" role="link" aria-label="#" class="ui-text-note"><small>GitHub</small></a></div></div></footer></body></html>